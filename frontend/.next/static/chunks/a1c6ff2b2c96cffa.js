(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,31279,e=>{"use strict";var t=e.i(36895),r=e.i(20637),a=e.i(29017),o=e.i(12926);class s extends a.BaseError{constructor({callbackSelector:e,cause:t,data:r,extraData:a,sender:s,urls:n}){super(t.shortMessage||"An error occurred while fetching for an offchain result.",{cause:t,metaMessages:[...t.metaMessages||[],t.metaMessages?.length?"":[],"Offchain Gateway Call:",n&&["  Gateway URL(s):",...n.map(e=>`    ${(0,o.getUrl)(e)}`)],`  Sender: ${s}`,`  Data: ${r}`,`  Callback selector: ${e}`,`  Extra data: ${a}`].flat(),name:"OffchainLookupError"})}}class n extends a.BaseError{constructor({result:e,url:t}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:[`Gateway URL: ${(0,o.getUrl)(t)}`,`Response: ${(0,r.stringify)(e)}`],name:"OffchainLookupResponseMalformedError"})}}class i extends a.BaseError{constructor({sender:e,to:t}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${t}`,`OffchainLookup sender address: ${e}`],name:"OffchainLookupSenderMismatchError"})}}var c=e.i(71436),u=e.i(29630),d=e.i(60179),l=e.i(1620),f=e.i(25835),p=e.i(31081),h=e.i(46824),w=e.i(38575),m=e.i(54459),y=e.i(43091),b=e.i(38155),g=e.i(34974),A=e.i(65887),E=e.i(84120),F=e.i(2868);let R="/docs/contract/encodeErrorResult";function O(e){let{abi:t,errorName:r,args:a}=e,o=t[0];if(r){let e=(0,F.getAbiItem)({abi:t,args:a,name:r});if(!e)throw new y.AbiErrorNotFoundError(r,{docsPath:R});o=e}if("error"!==o.type)throw new y.AbiErrorNotFoundError(void 0,{docsPath:R});let s=(0,E.formatAbiItem)(o),n=(0,g.toFunctionSelector)(s),i="0x";if(a&&a.length>0){if(!o.inputs)throw new y.AbiErrorInputsNotFoundError(o.name,{docsPath:R});i=(0,d.encodeAbiParameters)(o.inputs,a)}return(0,p.concatHex)([n,i])}let P="/docs/contract/encodeFunctionResult",v="x-batch-gateway:true";async function x(e){let{data:t,ccipRequest:r}=e,{args:[a]}=function(e){let{abi:t,data:r}=e,a=(0,b.slice)(r,0,4),o=t.find(e=>"function"===e.type&&a===(0,g.toFunctionSelector)((0,E.formatAbiItem)(e)));if(!o)throw new y.AbiFunctionSignatureNotFoundError(a,{docsPath:"/docs/contract/decodeFunctionData"});return{functionName:o.name,args:"inputs"in o&&o.inputs&&o.inputs.length>0?(0,A.decodeAbiParameters)(o.inputs,(0,b.slice)(r,4)):void 0}}({abi:w.batchGatewayAbi,data:t}),o=[],s=[];return await Promise.all(a.map(async(e,t)=>{try{s[t]=e.urls.includes(v)?await x({data:e.data,ccipRequest:r}):await r(e),o[t]=!1}catch(e){var a;o[t]=!0,s[t]="HttpRequestError"===(a=e).name&&a.status?O({abi:w.batchGatewayAbi,errorName:"HttpError",args:[a.status,a.shortMessage]}):O({abi:[m.solidityError],errorName:"Error",args:["shortMessage"in a?a.shortMessage:a.message]})}})),function(e){let{abi:t,functionName:r,result:a}=e,o=t[0];if(r){let e=(0,F.getAbiItem)({abi:t,name:r});if(!e)throw new y.AbiFunctionNotFoundError(r,{docsPath:P});o=e}if("function"!==o.type)throw new y.AbiFunctionNotFoundError(void 0,{docsPath:P});if(!o.outputs)throw new y.AbiFunctionOutputsNotFoundError(o.name,{docsPath:P});let s=(()=>{if(0===o.outputs.length)return[];if(1===o.outputs.length)return[a];if(Array.isArray(a))return a;throw new y.InvalidArrayError(a)})();return(0,d.encodeAbiParameters)(o.outputs,s)}({abi:w.batchGatewayAbi,functionName:"query",result:[o,s]})}let L={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};async function k(e,{blockNumber:r,blockTag:a,data:o,to:n}){let{args:c}=(0,u.decodeErrorResult)({data:o,abi:[L]}),[h,w,m,y,b]=c,{ccipRead:g}=e,A=g&&"function"==typeof g?.request?g.request:N;try{if(!function(e,t){if(!(0,f.isAddress)(e,{strict:!1}))throw new l.InvalidAddressError({address:e});if(!(0,f.isAddress)(t,{strict:!1}))throw new l.InvalidAddressError({address:t});return e.toLowerCase()===t.toLowerCase()}(n,h))throw new i({sender:h,to:n});let o=w.includes(v)?await x({data:m,ccipRequest:A}):await A({data:m,sender:h,urls:w}),{data:s}=await (0,t.call)(e,{blockNumber:r,blockTag:a,data:(0,p.concat)([y,(0,d.encodeAbiParameters)([{type:"bytes"},{type:"bytes"}],[o,b])]),to:n});return s}catch(e){throw new s({callbackSelector:y,cause:e,data:o,extraData:b,sender:h,urls:w})}}async function N({data:e,sender:t,urls:a}){let o=Error("An unknown error occurred.");for(let s=0;s<a.length;s++){let i=a[s],u=i.includes("{data}")?"GET":"POST",d="POST"===u?{data:e,sender:t}:void 0,l="POST"===u?{"Content-Type":"application/json"}:{};try{let a,s=await fetch(i.replace("{sender}",t.toLowerCase()).replace("{data}",e),{body:JSON.stringify(d),headers:l,method:u});if(a=s.headers.get("Content-Type")?.startsWith("application/json")?(await s.json()).data:await s.text(),!s.ok){o=new c.HttpRequestError({body:d,details:a?.error?(0,r.stringify)(a.error):s.statusText,headers:s.headers,status:s.status,url:i});continue}if(!(0,h.isHex)(a)){o=new n({result:a,url:i});continue}return a}catch(e){o=new c.HttpRequestError({body:d,details:e.message,url:i})}}throw o}e.s(["ccipRequest",()=>N,"offchainLookup",()=>k,"offchainLookupAbiItem",0,L,"offchainLookupSignature",0,"0x556f1830"],31279)}]);
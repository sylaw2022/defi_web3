{"version":3,"sources":["../../../../../frontend/node_modules/viem/utils/ccip.ts","../../../../../frontend/node_modules/viem/errors/ccip.ts","../../../../../frontend/node_modules/viem/utils/address/isAddressEqual.ts","../../../../../frontend/node_modules/viem/utils/abi/decodeFunctionData.ts","../../../../../frontend/node_modules/viem/utils/abi/encodeErrorResult.ts","../../../../../frontend/node_modules/viem/utils/abi/encodeFunctionResult.ts","../../../../../frontend/node_modules/viem/utils/ens/localBatchGatewayRequest.ts"],"sourcesContent":["import type { Abi, Address } from 'abitype'\n\nimport { type CallParameters, call } from '../actions/public/call.js'\nimport type { Client } from '../clients/createClient.js'\nimport type { Transport } from '../clients/transports/createTransport.js'\nimport type { BaseError } from '../errors/base.js'\nimport {\n  OffchainLookupError,\n  type OffchainLookupErrorType as OffchainLookupErrorType_,\n  OffchainLookupResponseMalformedError,\n  type OffchainLookupResponseMalformedErrorType,\n  OffchainLookupSenderMismatchError,\n} from '../errors/ccip.js'\nimport {\n  HttpRequestError,\n  type HttpRequestErrorType,\n} from '../errors/request.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport type { Chain } from '../types/chain.js'\nimport type { Hex } from '../types/misc.js'\nimport { decodeErrorResult } from './abi/decodeErrorResult.js'\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js'\nimport { isAddressEqual } from './address/isAddressEqual.js'\nimport { concat } from './data/concat.js'\nimport { isHex } from './data/isHex.js'\nimport {\n  localBatchGatewayRequest,\n  localBatchGatewayUrl,\n} from './ens/localBatchGatewayRequest.js'\nimport { stringify } from './stringify.js'\n\nexport const offchainLookupSignature = '0x556f1830'\nexport const offchainLookupAbiItem = {\n  name: 'OffchainLookup',\n  type: 'error',\n  inputs: [\n    {\n      name: 'sender',\n      type: 'address',\n    },\n    {\n      name: 'urls',\n      type: 'string[]',\n    },\n    {\n      name: 'callData',\n      type: 'bytes',\n    },\n    {\n      name: 'callbackFunction',\n      type: 'bytes4',\n    },\n    {\n      name: 'extraData',\n      type: 'bytes',\n    },\n  ],\n} as const satisfies Abi[number]\n\nexport type OffchainLookupErrorType = OffchainLookupErrorType_ | ErrorType\n\nexport async function offchainLookup<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    blockNumber,\n    blockTag,\n    data,\n    to,\n  }: Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    data: Hex\n    to: Address\n  },\n): Promise<Hex> {\n  const { args } = decodeErrorResult({\n    data,\n    abi: [offchainLookupAbiItem],\n  })\n  const [sender, urls, callData, callbackSelector, extraData] = args\n\n  const { ccipRead } = client\n  const ccipRequest_ =\n    ccipRead && typeof ccipRead?.request === 'function'\n      ? ccipRead.request\n      : ccipRequest\n\n  try {\n    if (!isAddressEqual(to, sender))\n      throw new OffchainLookupSenderMismatchError({ sender, to })\n\n    const result = urls.includes(localBatchGatewayUrl)\n      ? await localBatchGatewayRequest({\n          data: callData,\n          ccipRequest: ccipRequest_,\n        })\n      : await ccipRequest_({ data: callData, sender, urls })\n\n    const { data: data_ } = await call(client, {\n      blockNumber,\n      blockTag,\n      data: concat([\n        callbackSelector,\n        encodeAbiParameters(\n          [{ type: 'bytes' }, { type: 'bytes' }],\n          [result, extraData],\n        ),\n      ]),\n      to,\n    } as CallParameters)\n\n    return data_!\n  } catch (err) {\n    throw new OffchainLookupError({\n      callbackSelector,\n      cause: err as BaseError,\n      data,\n      extraData,\n      sender,\n      urls,\n    })\n  }\n}\n\nexport type CcipRequestParameters = {\n  data: Hex\n  sender: Address\n  urls: readonly string[]\n}\n\nexport type CcipRequestReturnType = Hex\n\nexport type CcipRequestErrorType =\n  | HttpRequestErrorType\n  | OffchainLookupResponseMalformedErrorType\n  | ErrorType\n\nexport async function ccipRequest({\n  data,\n  sender,\n  urls,\n}: CcipRequestParameters): Promise<CcipRequestReturnType> {\n  let error = new Error('An unknown error occurred.')\n\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i]\n    const method = url.includes('{data}') ? 'GET' : 'POST'\n    const body = method === 'POST' ? { data, sender } : undefined\n    const headers: HeadersInit =\n      method === 'POST' ? { 'Content-Type': 'application/json' } : {}\n\n    try {\n      const response = await fetch(\n        url.replace('{sender}', sender.toLowerCase()).replace('{data}', data),\n        {\n          body: JSON.stringify(body),\n          headers,\n          method,\n        },\n      )\n\n      let result: any\n      if (\n        response.headers.get('Content-Type')?.startsWith('application/json')\n      ) {\n        result = (await response.json()).data\n      } else {\n        result = (await response.text()) as any\n      }\n\n      if (!response.ok) {\n        error = new HttpRequestError({\n          body,\n          details: result?.error\n            ? stringify(result.error)\n            : response.statusText,\n          headers: response.headers,\n          status: response.status,\n          url,\n        })\n        continue\n      }\n\n      if (!isHex(result)) {\n        error = new OffchainLookupResponseMalformedError({\n          result,\n          url,\n        })\n        continue\n      }\n\n      return result\n    } catch (err) {\n      error = new HttpRequestError({\n        body,\n        details: (err as Error).message,\n        url,\n      })\n    }\n  }\n\n  throw error\n}\n","import type { Address } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { stringify } from '../utils/stringify.js'\n\nimport { BaseError } from './base.js'\nimport { getUrl } from './utils.js'\n\nexport type OffchainLookupErrorType = OffchainLookupError & {\n  name: 'OffchainLookupError'\n}\nexport class OffchainLookupError extends BaseError {\n  constructor({\n    callbackSelector,\n    cause,\n    data,\n    extraData,\n    sender,\n    urls,\n  }: {\n    callbackSelector: Hex\n    cause: BaseError\n    data: Hex\n    extraData: Hex\n    sender: Address\n    urls: readonly string[]\n  }) {\n    super(\n      cause.shortMessage ||\n        'An error occurred while fetching for an offchain result.',\n      {\n        cause,\n        metaMessages: [\n          ...(cause.metaMessages || []),\n          cause.metaMessages?.length ? '' : [],\n          'Offchain Gateway Call:',\n          urls && [\n            '  Gateway URL(s):',\n            ...urls.map((url) => `    ${getUrl(url)}`),\n          ],\n          `  Sender: ${sender}`,\n          `  Data: ${data}`,\n          `  Callback selector: ${callbackSelector}`,\n          `  Extra data: ${extraData}`,\n        ].flat(),\n        name: 'OffchainLookupError',\n      },\n    )\n  }\n}\n\nexport type OffchainLookupResponseMalformedErrorType =\n  OffchainLookupResponseMalformedError & {\n    name: 'OffchainLookupResponseMalformedError'\n  }\nexport class OffchainLookupResponseMalformedError extends BaseError {\n  constructor({ result, url }: { result: any; url: string }) {\n    super(\n      'Offchain gateway response is malformed. Response data must be a hex value.',\n      {\n        metaMessages: [\n          `Gateway URL: ${getUrl(url)}`,\n          `Response: ${stringify(result)}`,\n        ],\n        name: 'OffchainLookupResponseMalformedError',\n      },\n    )\n  }\n}\n\n/** @internal */\nexport type OffchainLookupSenderMismatchErrorType =\n  OffchainLookupSenderMismatchError & {\n    name: 'OffchainLookupSenderMismatchError'\n  }\nexport class OffchainLookupSenderMismatchError extends BaseError {\n  constructor({ sender, to }: { sender: Address; to: Address }) {\n    super(\n      'Reverted sender address does not match target contract address (`to`).',\n      {\n        metaMessages: [\n          `Contract address: ${to}`,\n          `OffchainLookup sender address: ${sender}`,\n        ],\n        name: 'OffchainLookupSenderMismatchError',\n      },\n    )\n  }\n}\n","import type { Address } from 'abitype'\n\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport { isAddress } from './isAddress.js'\n\nexport type IsAddressEqualReturnType = boolean\nexport type IsAddressEqualErrorType = InvalidAddressErrorType | ErrorType\n\nexport function isAddressEqual(a: Address, b: Address) {\n  if (!isAddress(a, { strict: false }))\n    throw new InvalidAddressError({ address: a })\n  if (!isAddress(b, { strict: false }))\n    throw new InvalidAddressError({ address: b })\n  return a.toLowerCase() === b.toLowerCase()\n}\n","import type { Abi, AbiStateMutability } from 'abitype'\n\nimport { AbiFunctionSignatureNotFoundError } from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport { type SliceErrorType, slice } from '../data/slice.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\nimport {\n  type DecodeAbiParametersErrorType,\n  decodeAbiParameters,\n} from './decodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\n\nexport type DecodeFunctionDataParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n> = {\n  abi: abi\n  data: Hex\n}\n\nexport type DecodeFunctionDataReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  ///\n  allFunctionNames extends\n    ContractFunctionName<abi> = ContractFunctionName<abi>,\n> = IsNarrowable<abi, Abi> extends true\n  ? UnionEvaluate<\n      {\n        [functionName in allFunctionNames]: {\n          args: ContractFunctionArgs<abi, AbiStateMutability, functionName>\n          functionName: functionName\n        }\n      }[allFunctionNames]\n    >\n  : {\n      args: readonly unknown[] | undefined\n      functionName: string\n    }\n\nexport type DecodeFunctionDataErrorType =\n  | AbiFunctionSignatureNotFoundError\n  | DecodeAbiParametersErrorType\n  | FormatAbiItemErrorType\n  | ToFunctionSelectorErrorType\n  | SliceErrorType\n  | ErrorType\n\nexport function decodeFunctionData<const abi extends Abi | readonly unknown[]>(\n  parameters: DecodeFunctionDataParameters<abi>,\n) {\n  const { abi, data } = parameters as DecodeFunctionDataParameters\n  const signature = slice(data, 0, 4)\n  const description = abi.find(\n    (x) =>\n      x.type === 'function' &&\n      signature === toFunctionSelector(formatAbiItem(x)),\n  )\n  if (!description)\n    throw new AbiFunctionSignatureNotFoundError(signature, {\n      docsPath: '/docs/contract/decodeFunctionData',\n    })\n  return {\n    functionName: (description as { name: string }).name,\n    args: ('inputs' in description &&\n    description.inputs &&\n    description.inputs.length > 0\n      ? decodeAbiParameters(description.inputs, slice(data, 4))\n      : undefined) as readonly unknown[] | undefined,\n  } as DecodeFunctionDataReturnType<abi>\n}\n","import type { Abi, ExtractAbiErrors } from 'abitype'\n\nimport {\n  AbiErrorInputsNotFoundError,\n  AbiErrorNotFoundError,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractErrorArgs,\n  ContractErrorName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport { type ConcatHexErrorType, concatHex } from '../data/concat.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from './encodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\nimport { type GetAbiItemErrorType, getAbiItem } from './getAbiItem.js'\n\nconst docsPath = '/docs/contract/encodeErrorResult'\n\nexport type EncodeErrorResultParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  errorName extends ContractErrorName<abi> | undefined = ContractErrorName<abi>,\n  ///\n  hasErrors = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiErrors<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allArgs = ContractErrorArgs<\n    abi,\n    errorName extends ContractErrorName<abi>\n      ? errorName\n      : ContractErrorName<abi>\n  >,\n  allErrorNames = ContractErrorName<abi>,\n> = {\n  abi: abi\n  args?: allArgs | undefined\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { errorName?: errorName | allErrorNames | undefined }\n      : { errorName: errorName | allErrorNames }\n    : { errorName?: errorName | allErrorNames | undefined }\n> &\n  (hasErrors extends true ? unknown : never)\n\nexport type EncodeErrorResultReturnType = Hex\n\nexport type EncodeErrorResultErrorType =\n  | GetAbiItemErrorType\n  | FormatAbiItemErrorType\n  | ToFunctionSelectorErrorType\n  | EncodeAbiParametersErrorType\n  | ConcatHexErrorType\n  | ErrorType\n\nexport function encodeErrorResult<\n  const abi extends Abi | readonly unknown[],\n  errorName extends ContractErrorName<abi> | undefined = undefined,\n>(\n  parameters: EncodeErrorResultParameters<abi, errorName>,\n): EncodeErrorResultReturnType {\n  const { abi, errorName, args } = parameters as EncodeErrorResultParameters\n\n  let abiItem = abi[0]\n  if (errorName) {\n    const item = getAbiItem({ abi, args, name: errorName })\n    if (!item) throw new AbiErrorNotFoundError(errorName, { docsPath })\n    abiItem = item\n  }\n\n  if (abiItem.type !== 'error')\n    throw new AbiErrorNotFoundError(undefined, { docsPath })\n\n  const definition = formatAbiItem(abiItem)\n  const signature = toFunctionSelector(definition)\n\n  let data: Hex = '0x'\n  if (args && args.length > 0) {\n    if (!abiItem.inputs)\n      throw new AbiErrorInputsNotFoundError(abiItem.name, { docsPath })\n    data = encodeAbiParameters(abiItem.inputs, args)\n  }\n  return concatHex([signature, data])\n}\n","import type { Abi, AbiStateMutability, ExtractAbiFunctions } from 'abitype'\n\nimport {\n  AbiFunctionNotFoundError,\n  AbiFunctionOutputsNotFoundError,\n  InvalidArrayError,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractFunctionName,\n  ContractFunctionReturnType,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from './encodeAbiParameters.js'\nimport { type GetAbiItemErrorType, getAbiItem } from './getAbiItem.js'\n\nconst docsPath = '/docs/contract/encodeFunctionResult'\n\nexport type EncodeFunctionResultParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends\n    | ContractFunctionName<abi>\n    | undefined = ContractFunctionName<abi>,\n  ///\n  hasFunctions = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiFunctions<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allFunctionNames = ContractFunctionName<abi>,\n> = {\n  abi: abi\n  result?:\n    | ContractFunctionReturnType<\n        abi,\n        AbiStateMutability,\n        functionName extends ContractFunctionName<abi>\n          ? functionName\n          : ContractFunctionName<abi>,\n        never // allow all args. required for overloads to work.\n      >\n    | undefined\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { functionName?: functionName | allFunctionNames | undefined }\n      : { functionName: functionName | allFunctionNames }\n    : { functionName?: functionName | allFunctionNames | undefined }\n> &\n  (hasFunctions extends true ? unknown : never)\n\nexport type EncodeFunctionResultReturnType = Hex\n\nexport type EncodeFunctionResultErrorType =\n  | AbiFunctionOutputsNotFoundError\n  | AbiFunctionNotFoundError\n  | EncodeAbiParametersErrorType\n  | GetAbiItemErrorType\n  | ErrorType\n\nexport function encodeFunctionResult<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi> | undefined = undefined,\n>(\n  parameters: EncodeFunctionResultParameters<abi, functionName>,\n): EncodeFunctionResultReturnType {\n  const { abi, functionName, result } =\n    parameters as EncodeFunctionResultParameters\n\n  let abiItem = abi[0]\n  if (functionName) {\n    const item = getAbiItem({ abi, name: functionName })\n    if (!item) throw new AbiFunctionNotFoundError(functionName, { docsPath })\n    abiItem = item\n  }\n\n  if (abiItem.type !== 'function')\n    throw new AbiFunctionNotFoundError(undefined, { docsPath })\n\n  if (!abiItem.outputs)\n    throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath })\n\n  const values = (() => {\n    if (abiItem.outputs.length === 0) return []\n    if (abiItem.outputs.length === 1) return [result]\n    if (Array.isArray(result)) return result\n    throw new InvalidArrayError(result)\n  })()\n\n  return encodeAbiParameters(abiItem.outputs, values)\n}\n","import { batchGatewayAbi } from '../../constants/abis.js'\nimport { solidityError } from '../../constants/solidity.js'\nimport type { Hex } from '../../types/misc.js'\nimport { decodeFunctionData } from '../abi/decodeFunctionData.js'\nimport { encodeErrorResult } from '../abi/encodeErrorResult.js'\nimport { encodeFunctionResult } from '../abi/encodeFunctionResult.js'\nimport type {\n  CcipRequestErrorType,\n  CcipRequestParameters,\n  CcipRequestReturnType,\n} from '../ccip.js'\n\nexport const localBatchGatewayUrl = 'x-batch-gateway:true'\n\nexport async function localBatchGatewayRequest(parameters: {\n  data: Hex\n  ccipRequest: (\n    parameters: CcipRequestParameters,\n  ) => Promise<CcipRequestReturnType>\n}): Promise<Hex> {\n  const { data, ccipRequest } = parameters\n\n  const {\n    args: [queries],\n  } = decodeFunctionData({ abi: batchGatewayAbi, data })\n\n  const failures: boolean[] = []\n  const responses: Hex[] = []\n  await Promise.all(\n    queries.map(async (query, i) => {\n      try {\n        responses[i] = query.urls.includes(localBatchGatewayUrl)\n          ? await localBatchGatewayRequest({ data: query.data, ccipRequest })\n          : await ccipRequest(query)\n        failures[i] = false\n      } catch (err) {\n        failures[i] = true\n        responses[i] = encodeError(err as CcipRequestErrorType)\n      }\n    }),\n  )\n\n  return encodeFunctionResult({\n    abi: batchGatewayAbi,\n    functionName: 'query',\n    result: [failures, responses],\n  })\n}\n\nfunction encodeError(error: CcipRequestErrorType): Hex {\n  if (error.name === 'HttpRequestError' && error.status)\n    return encodeErrorResult({\n      abi: batchGatewayAbi,\n      errorName: 'HttpError',\n      args: [error.status, error.shortMessage],\n    })\n  return encodeErrorResult({\n    abi: [solidityError],\n    errorName: 'Error',\n    args: ['shortMessage' in error ? error.shortMessage : error.message],\n  })\n}\n"],"names":[],"mappings":"uCAEA,IAAA,EGA4C,CDArC,ADCA,AGDA,ADAA,AHAA,AMFA,ADEA,CAE0B,CAC/B,AJFO,ADD4D,AECnE,ACDO,ACCP,ACAA,ACHO,ANEqB,CCCmB,ADDoB,AKGnE,CJF+C,AEDC,CAAqB,CAAA,AHArC,EAAE,GCClB,AKHuC,CAAA,CLGrC,AGCG,CJFmB,EIGzC,AFA+B,CAAA,AILR,ELGE,AKHA,ADKP,CADc,CHDZ,CGGpB,CDD2B,CAAA,AFA3B,CIL+B,CDGN,EAGnB,AAFL,CDD2B,CFEtB,CEDL,IDFwC,EAAE,YEIhB,CAAA,KJKf,CISC,SJT2B,EAAA,SAAS,CAChD,EIsDI,CA9CgD,CAAA,OLAQ,CMhBC,AFiB9B,AC6C3B,AL9CwD,AGF7B,CEgD3B,AC9DyD,AHc9B,ACGA,iBC6C3B,CJrDc,CAAA,MAAA,CACX,MACL,CAAA,WACA,CEG2E,ACGA,AFRjC,ADEjC,QACT,CAAA,CACA,CKbiE,CAAA,ILa7D,CAQL,CAAA,OAEG,EAAM,CGLmC,WAAA,EAAA,2DHOzC,4BAGc,YAAY,EAAA,EAAM,CAAC,AAC7B,CG0CK,CAAA,YH1Ca,EAAA,OAAW,GAAK,CDHO,CAAA,CCIzC,CKPK,wBLQL,CG0CG,EH1CK,CAAJ,AE+BA,CHlCU,sBCKT,EAAK,GAAG,CAAE,AAAD,GAAS,AE6BkB,AF7BvB,CAAI,CAAF,GAAE,EAAA,CAAA,EAAQ,EAAA,MAAA,EAAO,GAAA,CAAM,CKNG,ALMF,CAC3C,cACY,EKNI,ALME,CKNF,AFgDG,AH1CC,CE+BG,EF/BL,YACF,CACjB,CAAA,CKPQ,CDsDH,mBAAA,EJ/CmB,CE+BD,CF/BiB,CAAE,CAC1C,AG0CgC,CH1ChC,AG0CiC,CAAA,UH3CO,GACxC,EAAA,EAAA,CAA4B,CE+BC,AF9B9B,CAAA,IAAK,CG4CQ,ACEP,gCJzCd,AAMK,MAAO,GDTH,OCSgD,EAAA,SAAS,CACjE,YAAY,QAAE,CAAM,CKXD,ILWG,CAAG,CAAgC,CAAA,MAClD,CACH,4EAA4E,CAC5E,cACgB,UDXQ,OCYJ,CAAA,EAAA,EAAA,MAAA,AAAM,EAAC,GAAG,AAAC,CAAA,AAAE,CAC7B,CAAA,UAA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","ignoreList":[0,1,2,3,4,5,6]}